

Let's build these properly and completely.

---

## 1. Contract Analysis (Gemini 3 Flash)

### Install Dependencies

```bash
npm install @ai-sdk/google ai pdf-parse mammoth
```

### `src/lib/ai/index.ts`

```typescript
import { createGoogleGenerativeAI } from "@ai-sdk/google";

if (!process.env.GOOGLE_GENERATIVE_AI_API_KEY) {
  throw new Error("GOOGLE_GENERATIVE_AI_API_KEY is not set");
}

export const google = createGoogleGenerativeAI({
  apiKey: process.env.GOOGLE_GENERATIVE_AI_API_KEY,
});

// Default model for contract analysis
export const contractAnalysisModel = google("gemini-2.0-flash-001");

// For longer documents or more complex analysis
export const contractAnalysisModelPro = google("gemini-1.5-pro");
```

### `src/lib/ai/contract-analyzer.ts`

```typescript
import { generateObject } from "ai";
import { z } from "zod";
import { contractAnalysisModel } from "./index";

// Schema for contract analysis output
export const ContractAnalysisSchema = z.object({
  summary: z.string().describe("Brief 2-3 sentence summary of the contract"),

  parties: z.object({
    client: z.object({
      name: z.string(),
      role: z.string().optional(),
    }),
    contractor: z.object({
      name: z.string(),
      role: z.string().optional(),
    }),
  }),

  contractType: z.enum([
    "SERVICE_AGREEMENT",
    "NDA",
    "EMPLOYMENT",
    "CONSULTING",
    "LICENSING",
    "PARTNERSHIP",
    "OTHER",
  ]),

  financials: z.object({
    totalValue: z.number().nullable(),
    currency: z.string().default("USD"),
    paymentTerms: z.enum([
      "NET_15",
      "NET_30",
      "NET_45",
      "NET_60",
      "NET_90",
      "ON_COMPLETION",
      "MILESTONE",
      "UPFRONT",
      "OTHER",
    ]),
    paymentTermsRaw: z.string().describe("Exact payment terms from contract"),
    depositRequired: z.boolean(),
    depositPercentage: z.number().nullable(),
    latePaymentPenalty: z.string().nullable(),
  }),

  scope: z.array(
    z.object({
      description: z.string(),
      category: z.enum([
        "DELIVERABLE",
        "SERVICE",
        "MILESTONE",
        "REVISION",
        "SUPPORT",
        "OTHER",
      ]),
      isQuantified: z.boolean(),
      quantity: z.string().nullable(),
    })
  ),

  timeline: z.object({
    startDate: z.string().nullable(),
    endDate: z.string().nullable(),
    duration: z.string().nullable(),
    milestones: z.array(
      z.object({
        name: z.string(),
        date: z.string().nullable(),
        description: z.string().nullable(),
      })
    ),
  }),

  risks: z.array(
    z.object({
      clause: z.string().describe("The exact problematic clause text"),
      category: z.enum([
        "IP_OWNERSHIP",
        "PAYMENT_TERMS",
        "SCOPE_AMBIGUITY",
        "LIABILITY",
        "TERMINATION",
        "NON_COMPETE",
        "INDEMNIFICATION",
        "CONFIDENTIALITY",
        "UNLIMITED_REVISIONS",
        "WORK_FOR_HIRE",
        "KILL_FEE",
        "OTHER",
      ]),
      severity: z.enum(["LOW", "MEDIUM", "HIGH", "CRITICAL"]),
      explanation: z.string().describe("Why this is risky for the freelancer"),
      recommendation: z.string().describe("What to do about it"),
      suggestedRevision: z
        .string()
        .nullable()
        .describe("Suggested replacement clause language"),
    })
  ),

  positives: z.array(
    z.object({
      clause: z.string(),
      description: z.string(),
    })
  ).describe("Good clauses that protect the freelancer"),

  missingClauses: z.array(
    z.object({
      clause: z.string(),
      importance: z.enum(["RECOMMENDED", "IMPORTANT", "CRITICAL"]),
      suggestedLanguage: z.string(),
    })
  ).describe("Important clauses that are missing from the contract"),

  overallRiskScore: z
    .number()
    .min(0)
    .max(100)
    .describe("100 = safest, 0 = most risky"),

  negotiationPriority: z.array(z.string()).describe(
    "Top 3-5 items to negotiate, in order of importance"
  ),
});

export type ContractAnalysis = z.infer<typeof ContractAnalysisSchema>;

const SYSTEM_PROMPT = `You are an expert contract analyst specializing in freelance and independent contractor agreements. Your job is to protect freelancers from unfavorable contract terms.

ANALYSIS GUIDELINES:

1. **Payment Terms Benchmarks**:
   - NET-30 is standard and acceptable
   - NET-45+ is unfavorable (flag as MEDIUM risk)
   - NET-60+ is highly unfavorable (flag as HIGH risk)
   - NET-90 is unacceptable (flag as CRITICAL risk)
   - No deposit on large projects is risky

2. **IP/Work Product Red Flags**:
   - "All work product becomes client property upon creation" - CRITICAL
   - "Work for hire" without payment protection - HIGH
   - IP transfers before payment - CRITICAL
   - Client owns unused concepts/drafts - HIGH
   - No portfolio rights - MEDIUM

3. **Scope Red Flags**:
   - "Unlimited revisions" - CRITICAL
   - Vague deliverables without quantities - HIGH  
   - No revision limits specified - MEDIUM
   - Scope changes without change orders - HIGH

4. **Liability Red Flags**:
   - Unlimited indemnification - CRITICAL
   - No liability cap - HIGH
   - Indemnification not mutual - MEDIUM
   - Contractor liable for third-party actions - HIGH

5. **Termination Red Flags**:
   - Client can terminate without payment for work done - CRITICAL
   - No kill fee - MEDIUM
   - Work transfers on termination regardless of payment - CRITICAL
   - Very short notice period (< 7 days) - MEDIUM

6. **Non-Compete Red Flags**:
   - > 12 months duration - HIGH
   - > 6 months for project-based work - MEDIUM
   - Overly broad geographic/industry scope - HIGH
   - Prevents working in your field - CRITICAL

7. **Missing Clauses to Flag**:
   - No late payment penalties
   - No kill fee/cancellation terms
   - No IP retention until payment
   - No revision limits
   - No scope change process
   - No dispute resolution

Always explain risks in plain language and provide specific, actionable recommendations.
Calculate the risk score based on:
- Start at 100
- CRITICAL issues: -25 points each
- HIGH issues: -15 points each  
- MEDIUM issues: -8 points each
- LOW issues: -3 points each
- Missing important clauses: -5 points each
- Minimum score: 0`;

export async function analyzeContract(
  contractText: string
): Promise<ContractAnalysis> {
  const { object } = await generateObject({
    model: contractAnalysisModel,
    schema: ContractAnalysisSchema,
    system: SYSTEM_PROMPT,
    prompt: `Analyze this contract and identify all risks, issues, and recommendations:

---CONTRACT START---
${contractText}
---CONTRACT END---

Provide a thorough analysis focusing on protecting the freelancer/contractor.`,
  });

  return object;
}

export async function generateNegotiationEmail(
  analysis: ContractAnalysis,
  selectedRisks: ContractAnalysis["risks"],
  tone: "professional" | "friendly" | "firm" = "professional"
): Promise<string> {
  const { text } = await import("ai").then((m) =>
    m.generateText({
      model: contractAnalysisModel,
      system: `You are an expert negotiation coach for freelancers. Write professional, persuasive emails that protect the freelancer's interests while maintaining good client relationships.

Tone: ${tone}
- professional: Formal, business-like, focuses on industry standards
- friendly: Warm but still professional, emphasizes partnership
- firm: Direct, confident, emphasizes non-negotiables`,
      prompt: `Write a negotiation email for a freelancer who needs to address these contract issues:

Contract Summary: ${analysis.summary}

Issues to Address:
${selectedRisks
  .map(
    (r, i) => `${i + 1}. ${r.category}: ${r.explanation}
   Recommendation: ${r.recommendation}
   Suggested revision: ${r.suggestedRevision || "N/A"}`
  )
  .join("\n\n")}

Write a complete email that:
1. Thanks them for the contract
2. Expresses enthusiasm about the project
3. Addresses each issue diplomatically
4. Proposes specific alternatives
5. Invites discussion
6. Maintains a positive, collaborative tone

Do not use placeholder text - write the complete email.`,
    })
  );

  return text;
}
```

### `src/lib/ai/document-parser.ts`

```typescript
import pdf from "pdf-parse";
import mammoth from "mammoth";

export async function parseDocument(
  buffer: Buffer,
  mimeType: string
): Promise<string> {
  switch (mimeType) {
    case "application/pdf":
      return parsePDF(buffer);

    case "application/msword":
    case "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
      return parseWord(buffer);

    case "text/plain":
      return buffer.toString("utf-8");

    default:
      throw new Error(`Unsupported file type: ${mimeType}`);
  }
}

async function parsePDF(buffer: Buffer): Promise<string> {
  try {
    const data = await pdf(buffer);
    return data.text;
  } catch (error) {
    console.error("PDF parsing error:", error);
    throw new Error("Failed to parse PDF. Please ensure it's a valid PDF file.");
  }
}

async function parseWord(buffer: Buffer): Promise<string> {
  try {
    const result = await mammoth.extractRawText({ buffer });
    return result.value;
  } catch (error) {
    console.error("Word parsing error:", error);
    throw new Error("Failed to parse Word document.");
  }
}
```

### `src/app/api/contracts/analyze/route.ts`

```typescript
import { auth } from "@clerk/nextjs/server";
import { NextRequest, NextResponse } from "next/server";
import { db } from "@/lib/db";
import { users, contracts, scopeItems } from "@/lib/db/schema";
import { eq } from "drizzle-orm";
import { analyzeContract } from "@/lib/ai/contract-analyzer";
import { parseDocument } from "@/lib/ai/document-parser";

export const maxDuration = 60; // Allow up to 60 seconds for analysis

export async function POST(req: NextRequest) {
  try {
    const { userId: clerkId } = await auth();

    if (!clerkId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const user = await db.query.users.findFirst({
      where: eq(users.clerkId, clerkId),
    });

    if (!user) {
      return NextResponse.json({ error: "User not found" }, { status: 404 });
    }

    // Get file from form data
    const formData = await req.formData();
    const file = formData.get("file") as File | null;
    const clientId = formData.get("clientId") as string | null;

    if (!file) {
      return NextResponse.json({ error: "No file provided" }, { status: 400 });
    }

    // Validate file size (10MB max)
    if (file.size > 10 * 1024 * 1024) {
      return NextResponse.json(
        { error: "File too large. Maximum size is 10MB." },
        { status: 400 }
      );
    }

    // Parse document
    const buffer = Buffer.from(await file.arrayBuffer());
    let contractText: string;

    try {
      contractText = await parseDocument(buffer, file.type);
    } catch (error) {
      return NextResponse.json(
        { error: error instanceof Error ? error.message : "Failed to parse document" },
        { status: 400 }
      );
    }

    if (!contractText || contractText.trim().length < 100) {
      return NextResponse.json(
        { error: "Could not extract enough text from the document. Please try a different file." },
        { status: 400 }
      );
    }

    // Analyze with AI
    let analysis;
    try {
      analysis = await analyzeContract(contractText);
    } catch (error) {
      console.error("AI analysis error:", error);
      return NextResponse.json(
        { error: "Failed to analyze contract. Please try again." },
        { status: 500 }
      );
    }

    // Generate title from analysis
    const title = `${analysis.contractType.replace(/_/g, " ")} - ${analysis.parties.client.name}`;

    // Save to database
    const [contract] = await db
      .insert(contracts)
      .values({
        userId: user.id,
        clientId: clientId || null,
        title,
        status: "pending_review",
        originalFileName: file.name,
        parsedContent: contractText,
        extractedTerms: analysis,
        riskScore: analysis.overallRiskScore,
        riskFlags: analysis.risks,
        paymentTerms: analysis.financials.paymentTerms,
        totalValue: analysis.financials.totalValue?.toString() || null,
        currency: analysis.financials.currency,
        startDate: analysis.timeline.startDate,
        endDate: analysis.timeline.endDate,
      })
      .returning();

    // Save scope items
    if (analysis.scope.length > 0) {
      await db.insert(scopeItems).values(
        analysis.scope.map((item) => ({
          contractId: contract.id,
          description: item.description,
          category: item.category,
          deliverableType: item.category,
          status: "pending" as const,
        }))
      );
    }

    return NextResponse.json({
      success: true,
      contractId: contract.id,
      analysis,
    });
  } catch (error) {
    console.error("Contract analysis error:", error);
    return NextResponse.json(
      { error: "An unexpected error occurred" },
      { status: 500 }
    );
  }
}
```

### `src/app/api/contracts/[id]/negotiate/route.ts`

```typescript
import { auth } from "@clerk/nextjs/server";
import { NextRequest, NextResponse } from "next/server";
import { db } from "@/lib/db";
import { users, contracts } from "@/lib/db/schema";
import { eq, and } from "drizzle-orm";
import { generateNegotiationEmail, ContractAnalysis } from "@/lib/ai/contract-analyzer";

export async function POST(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const { userId: clerkId } = await auth();

    if (!clerkId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const user = await db.query.users.findFirst({
      where: eq(users.clerkId, clerkId),
    });

    if (!user) {
      return NextResponse.json({ error: "User not found" }, { status: 404 });
    }

    const contract = await db.query.contracts.findFirst({
      where: and(
        eq(contracts.id, params.id),
        eq(contracts.userId, user.id)
      ),
    });

    if (!contract) {
      return NextResponse.json({ error: "Contract not found" }, { status: 404 });
    }

    const body = await req.json();
    const { selectedRiskIndices, tone = "professional" } = body;

    if (!selectedRiskIndices || !Array.isArray(selectedRiskIndices)) {
      return NextResponse.json(
        { error: "selectedRiskIndices is required" },
        { status: 400 }
      );
    }

    const analysis = contract.extractedTerms as ContractAnalysis;
    const selectedRisks = selectedRiskIndices.map(
      (i: number) => analysis.risks[i]
    ).filter(Boolean);

    if (selectedRisks.length === 0) {
      return NextResponse.json(
        { error: "No valid risks selected" },
        { status: 400 }
      );
    }

    const email = await generateNegotiationEmail(analysis, selectedRisks, tone);

    return NextResponse.json({ email });
  } catch (error) {
    console.error("Negotiation email error:", error);
    return NextResponse.json(
      { error: "Failed to generate negotiation email" },
      { status: 500 }
    );
  }
}
```

---

## 2. File Uploads (Using UploadThing)

### Install Dependencies

```bash
npm install uploadthing @uploadthing/react
```

### `src/lib/uploadthing.ts`

```typescript
import { createUploadthing, type FileRouter } from "uploadthing/next";
import { auth } from "@clerk/nextjs/server";
import { db } from "@/lib/db";
import { users } from "@/lib/db/schema";
import { eq } from "drizzle-orm";

const f = createUploadthing();

async function authMiddleware() {
  const { userId: clerkId } = await auth();

  if (!clerkId) {
    throw new Error("Unauthorized");
  }

  const user = await db.query.users.findFirst({
    where: eq(users.clerkId, clerkId),
  });

  if (!user) {
    throw new Error("User not found");
  }

  return { userId: user.id, clerkId };
}

export const uploadRouter = {
  // Contract documents
  contractDocument: f({
    pdf: { maxFileSize: "16MB", maxFileCount: 1 },
    "application/msword": { maxFileSize: "16MB", maxFileCount: 1 },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
      maxFileSize: "16MB",
      maxFileCount: 1,
    },
  })
    .middleware(authMiddleware)
    .onUploadComplete(async ({ metadata, file }) => {
      console.log("Contract uploaded:", file.url);
      return { uploadedBy: metadata.userId, url: file.url };
    }),

  // Portfolio images
  portfolioImage: f({
    image: { maxFileSize: "8MB", maxFileCount: 10 },
  })
    .middleware(authMiddleware)
    .onUploadComplete(async ({ metadata, file }) => {
      console.log("Portfolio image uploaded:", file.url);
      return { uploadedBy: metadata.userId, url: file.url };
    }),

  // Testimonial videos
  testimonialVideo: f({
    video: { maxFileSize: "64MB", maxFileCount: 1 },
  })
    .middleware(authMiddleware)
    .onUploadComplete(async ({ metadata, file }) => {
      console.log("Testimonial video uploaded:", file.url);
      return { uploadedBy: metadata.userId, url: file.url };
    }),

  // Avatar/profile images
  avatar: f({
    image: { maxFileSize: "4MB", maxFileCount: 1 },
  })
    .middleware(authMiddleware)
    .onUploadComplete(async ({ metadata, file }) => {
      console.log("Avatar uploaded:", file.url);
      return { uploadedBy: metadata.userId, url: file.url };
    }),
} satisfies FileRouter;

export type OurFileRouter = typeof uploadRouter;
```

### `src/app/api/uploadthing/core.ts`

```typescript
export { uploadRouter as ourFileRouter } from "@/lib/uploadthing";
```

### `src/app/api/uploadthing/route.ts`

```typescript
import { createRouteHandler } from "uploadthing/next";
import { uploadRouter } from "@/lib/uploadthing";

export const { GET, POST } = createRouteHandler({
  router: uploadRouter,
  config: {
    token: process.env.UPLOADTHING_TOKEN,
  },
});
```

### `src/components/ui/file-upload.tsx`

```typescript
"use client";

import { useCallback, useState } from "react";
import { useDropzone } from "react-dropzone";
import { generateReactHelpers } from "@uploadthing/react";
import type { OurFileRouter } from "@/lib/uploadthing";
import { cn } from "@/lib/utils";
import { Button } from "./button";
import { Progress } from "./progress";
import {
  Upload,
  FileText,
  Image as ImageIcon,
  Video,
  X,
  Loader2,
  CheckCircle,
  AlertCircle,
} from "lucide-react";

const { useUploadThing } = generateReactHelpers<OurFileRouter>();

interface FileUploadProps {
  endpoint: keyof OurFileRouter;
  onUploadComplete: (url: string) => void;
  onUploadError?: (error: Error) => void;
  accept?: Record<string, string[]>;
  maxSize?: number;
  className?: string;
  children?: React.ReactNode;
}

export function FileUpload({
  endpoint,
  onUploadComplete,
  onUploadError,
  accept,
  maxSize = 10 * 1024 * 1024,
  className,
  children,
}: FileUploadProps) {
  const [file, setFile] = useState<File | null>(null);
  const [uploading, setUploading] = useState(false);
  const [progress, setProgress] = useState(0);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState(false);

  const { startUpload } = useUploadThing(endpoint, {
    onUploadProgress: (p) => setProgress(p),
    onClientUploadComplete: (res) => {
      setUploading(false);
      setSuccess(true);
      if (res?.[0]?.url) {
        onUploadComplete(res[0].url);
      }
    },
    onUploadError: (err) => {
      setUploading(false);
      setError(err.message);
      onUploadError?.(err);
    },
  });

  const onDrop = useCallback(
    async (acceptedFiles: File[]) => {
      const file = acceptedFiles[0];
      if (!file) return;

      setFile(file);
      setError(null);
      setSuccess(false);
      setUploading(true);
      setProgress(0);

      await startUpload([file]);
    },
    [startUpload]
  );

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept,
    maxSize,
    maxFiles: 1,
    disabled: uploading,
  });

  const removeFile = () => {
    setFile(null);
    setError(null);
    setSuccess(false);
    setProgress(0);
  };

  const getIcon = () => {
    if (!file) return <Upload className="w-10 h-10 text-neutral-500" />;
    if (file.type.startsWith("image/"))
      return <ImageIcon className="w-10 h-10 text-neutral-500" />;
    if (file.type.startsWith("video/"))
      return <Video className="w-10 h-10 text-neutral-500" />;
    return <FileText className="w-10 h-10 text-neutral-500" />;
  };

  return (
    <div className={className}>
      <div
        {...getRootProps()}
        className={cn(
          "relative border-2 border-dashed rounded-xl p-8 text-center cursor-pointer transition-all",
          isDragActive
            ? "border-brand-500 bg-brand-500/5"
            : "border-neutral-700 hover:border-neutral-600",
          uploading && "pointer-events-none opacity-70",
          error && "border-danger/50",
          success && "border-success/50"
        )}
      >
        <input {...getInputProps()} />

        {file ? (
          <div className="space-y-4">
            <div className="flex items-center justify-center gap-4">
              {getIcon()}
              <div className="text-left">
                <p className="font-medium text-neutral-100 truncate max-w-xs">
                  {file.name}
                </p>
                <p className="text-sm text-neutral-400">
                  {(file.size / 1024 / 1024).toFixed(2)} MB
                </p>
              </div>
              {!uploading && !success && (
                <Button
                  type="button"
                  variant="ghost"
                  size="icon-sm"
                  onClick={(e) => {
                    e.stopPropagation();
                    removeFile();
                  }}
                >
                  <X className="w-4 h-4" />
                </Button>
              )}
            </div>

            {uploading && (
              <div className="space-y-2">
                <Progress value={progress} />
                <p className="text-sm text-neutral-400 flex items-center justify-center gap-2">
                  <Loader2 className="w-4 h-4 animate-spin" />
                  Uploading... {progress}%
                </p>
              </div>
            )}

            {success && (
              <p className="text-sm text-success flex items-center justify-center gap-2">
                <CheckCircle className="w-4 h-4" />
                Upload complete!
              </p>
            )}

            {error && (
              <p className="text-sm text-danger flex items-center justify-center gap-2">
                <AlertCircle className="w-4 h-4" />
                {error}
              </p>
            )}
          </div>
        ) : (
          children || (
            <>
              {getIcon()}
              <p className="mt-4 text-neutral-300">
                {isDragActive
                  ? "Drop your file here..."
                  : "Drag & drop a file, or click to browse"}
              </p>
              <p className="text-sm text-neutral-500 mt-1">
                Max size: {(maxSize / 1024 / 1024).toFixed(0)}MB
              </p>
            </>
          )
        )}
      </div>
    </div>
  );
}
```

### `src/components/ui/contract-upload.tsx`

```typescript
"use client";

import { useState, useCallback } from "react";
import { useRouter } from "next/navigation";
import { useDropzone } from "react-dropzone";
import { Card } from "./card";
import { Button } from "./button";
import { Progress } from "./progress";
import { cn } from "@/lib/utils";
import {
  Upload,
  FileText,
  Shield,
  Loader2,
  X,
  AlertCircle,
} from "lucide-react";
import { toast } from "sonner";

interface ContractUploadProps {
  onAnalysisComplete?: (contractId: string, analysis: any) => void;
  className?: string;
}

type UploadState = "idle" | "uploading" | "analyzing" | "complete" | "error";

export function ContractUpload({
  onAnalysisComplete,
  className,
}: ContractUploadProps) {
  const router = useRouter();
  const [state, setState] = useState<UploadState>("idle");
  const [file, setFile] = useState<File | null>(null);
  const [progress, setProgress] = useState(0);
  const [error, setError] = useState<string | null>(null);

  const onDrop = useCallback((acceptedFiles: File[]) => {
    const file = acceptedFiles[0];
    if (file) {
      setFile(file);
      setError(null);
    }
  }, []);

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept: {
      "application/pdf": [".pdf"],
      "application/msword": [".doc"],
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
        [".docx"],
      "text/plain": [".txt"],
    },
    maxFiles: 1,
    maxSize: 16 * 1024 * 1024,
    disabled: state !== "idle",
  });

  const handleAnalyze = async () => {
    if (!file) return;

    setState("uploading");
    setProgress(0);
    setError(null);

    // Simulate upload progress
    const progressInterval = setInterval(() => {
      setProgress((prev) => Math.min(prev + 10, 40));
    }, 200);

    try {
      const formData = new FormData();
      formData.append("file", file);

      clearInterval(progressInterval);
      setProgress(50);
      setState("analyzing");

      const response = await fetch("/api/contracts/analyze", {
        method: "POST",
        body: formData,
      });

      // Simulate analysis progress
      const analysisInterval = setInterval(() => {
        setProgress((prev) => Math.min(prev + 5, 95));
      }, 500);

      const data = await response.json();

      clearInterval(analysisInterval);

      if (!response.ok) {
        throw new Error(data.error || "Analysis failed");
      }

      setProgress(100);
      setState("complete");

      toast.success("Contract analyzed successfully!");

      if (onAnalysisComplete) {
        onAnalysisComplete(data.contractId, data.analysis);
      } else {
        // Navigate to contract detail
        router.push(`/dashboard/contracts/${data.contractId}`);
      }
    } catch (err) {
      setState("error");
      const message = err instanceof Error ? err.message : "Something went wrong";
      setError(message);
      toast.error(message);
    }
  };

  const reset = () => {
    setFile(null);
    setState("idle");
    setProgress(0);
    setError(null);
  };

  return (
    <Card className={cn("overflow-hidden", className)}>
      {state === "idle" && (
        <>
          <div
            {...getRootProps()}
            className={cn(
              "p-12 text-center cursor-pointer transition-all",
              isDragActive && "bg-shield/5"
            )}
          >
            <input {...getInputProps()} />
            <div
              className={cn(
                "mx-auto w-16 h-16 rounded-2xl flex items-center justify-center mb-6 transition-colors",
                isDragActive ? "bg-shield/20" : "bg-neutral-800"
              )}
            >
              {file ? (
                <FileText className="w-8 h-8 text-shield" />
              ) : (
                <Upload className="w-8 h-8 text-neutral-500" />
              )}
            </div>

            {file ? (
              <div>
                <p className="font-medium text-neutral-100">{file.name}</p>
                <p className="text-sm text-neutral-400 mt-1">
                  {(file.size / 1024 / 1024).toFixed(2)} MB
                </p>
                <button
                  type="button"
                  onClick={(e) => {
                    e.stopPropagation();
                    setFile(null);
                  }}
                  className="text-sm text-neutral-500 hover:text-neutral-300 mt-2"
                >
                  Remove
                </button>
              </div>
            ) : (
              <>
                <p className="text-neutral-300">
                  {isDragActive
                    ? "Drop your contract here..."
                    : "Drag & drop your contract here"}
                </p>
                <p className="text-sm text-neutral-500 mt-2">
                  or click to browse • PDF, DOC, DOCX, TXT up to 16MB
                </p>
              </>
            )}
          </div>

          {file && (
            <div className="p-4 border-t border-neutral-800">
              <Button
                onClick={handleAnalyze}
                variant="shield"
                className="w-full"
              >
                <Shield className="w-4 h-4 mr-2" />
                Analyze Contract
              </Button>
            </div>
          )}
        </>
      )}

      {(state === "uploading" || state === "analyzing") && (
        <div className="p-12 text-center">
          <div className="mx-auto w-16 h-16 rounded-2xl bg-shield/10 flex items-center justify-center mb-6">
            <Loader2 className="w-8 h-8 text-shield animate-spin" />
          </div>
          <h3 className="text-lg font-medium text-neutral-100 mb-2">
            {state === "uploading" ? "Uploading document..." : "Analyzing contract..."}
          </h3>
          <p className="text-neutral-400 mb-6 max-w-sm mx-auto">
            {state === "uploading"
              ? "Securely uploading your document."
              : "AI is reviewing terms, identifying risks, and benchmarking against industry standards."}
          </p>
          <div className="max-w-xs mx-auto">
            <Progress value={progress} />
            <p className="text-sm text-neutral-500 mt-2">{progress}%</p>
          </div>
        </div>
      )}

      {state === "error" && (
        <div className="p-12 text-center">
          <div className="mx-auto w-16 h-16 rounded-2xl bg-danger/10 flex items-center justify-center mb-6">
            <AlertCircle className="w-8 h-8 text-danger" />
          </div>
          <h3 className="text-lg font-medium text-neutral-100 mb-2">
            Analysis Failed
          </h3>
          <p className="text-neutral-400 mb-6 max-w-sm mx-auto">{error}</p>
          <Button onClick={reset} variant="outline">
            Try Again
          </Button>
        </div>
      )}
    </Card>
  );
}
```

### Update `src/app/(dashboard)/dashboard/contracts/analyze/page.tsx`

```typescript
import { ContractUpload } from "@/components/ui/contract-upload";
import { Shield } from "lucide-react";

export default function ContractAnalyzePage() {
  return (
    <div className="max-w-3xl mx-auto space-y-8">
      {/* Header */}
      <div className="text-center">
        <div className="inline-flex items-center justify-center w-16 h-16 rounded-2xl bg-gradient-to-br from-shield to-shield-dark mb-4">
          <Shield className="w-8 h-8 text-white" />
        </div>
        <h1 className="text-2xl font-semibold text-neutral-100">
          Contract Analysis
        </h1>
        <p className="text-neutral-400 mt-2 max-w-md mx-auto">
          Upload your contract and let Sovereign's AI identify risks,
          unfavorable terms, and suggest improvements.
        </p>
      </div>

      {/* Upload Component */}
      <ContractUpload />

      {/* Info */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4 text-center">
        <div className="p-4 rounded-lg bg-neutral-900/50 border border-neutral-800">
          <p className="text-2xl font-bold text-shield mb-1">30s</p>
          <p className="text-sm text-neutral-400">Average analysis time</p>
        </div>
        <div className="p-4 rounded-lg bg-neutral-900/50 border border-neutral-800">
          <p className="text-2xl font-bold text-shield mb-1">50+</p>
          <p className="text-sm text-neutral-400">Risk factors checked</p>
        </div>
        <div className="p-4 rounded-lg bg-neutral-900/50 border border-neutral-800">
          <p className="text-2xl font-bold text-shield mb-1">100%</p>
          <p className="text-sm text-neutral-400">Confidential & secure</p>
        </div>
      </div>
    </div>
  );
}
```

---

## 3. Testimonial System (with Email via Resend)

### Install Dependencies

```bash
npm install resend
```

### `src/lib/email/index.ts`

```typescript
import { Resend } from "resend";

if (!process.env.RESEND_API_KEY) {
  console.warn("RESEND_API_KEY not set - emails will be logged only");
}

export const resend = process.env.RESEND_API_KEY
  ? new Resend(process.env.RESEND_API_KEY)
  : null;

export async function sendEmail({
  to,
  subject,
  html,
  from = "Sovereign <noreply@yourdomain.com>",
}: {
  to: string;
  subject: string;
  html: string;
  from?: string;
}) {
  if (!resend) {
    console.log("=== EMAIL (not sent - no API key) ===");
    console.log("To:", to);
    console.log("Subject:", subject);
    console.log("HTML:", html);
    console.log("=====================================");
    return { success: true, id: "dev-mode" };
  }

  try {
    const { data, error } = await resend.emails.send({
      from,
      to,
      subject,
      html,
    });

    if (error) {
      throw error;
    }

    return { success: true, id: data?.id };
  } catch (error) {
    console.error("Email send error:", error);
    throw error;
  }
}
```

### `src/lib/email/templates/testimonial-request.ts`

```typescript
interface TestimonialRequestEmailProps {
  freelancerName: string;
  clientName: string;
  magicLink: string;
  projectName?: string;
}

export function testimonialRequestEmail({
  freelancerName,
  clientName,
  magicLink,
  projectName,
}: TestimonialRequestEmailProps): string {
  return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Share Your Experience</title>
</head>
<body style="margin: 0; padding: 0; background-color: #0a0a0a; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
  <table width="100%" cellpadding="0" cellspacing="0" style="background-color: #0a0a0a; padding: 40px 20px;">
    <tr>
      <td align="center">
        <table width="100%" cellpadding="0" cellspacing="0" style="max-width: 600px; background-color: #171717; border-radius: 16px; overflow: hidden;">
          <!-- Header -->
          <tr>
            <td style="padding: 40px 40px 20px; text-align: center;">
              <div style="width: 60px; height: 60px; background: linear-gradient(135deg, #8b5cf6, #7c3aed); border-radius: 16px; margin: 0 auto 20px; display: flex; align-items: center; justify-content: center;">
                <span style="font-size: 28px;">✨</span>
              </div>
              <h1 style="margin: 0; color: #ffffff; font-size: 24px; font-weight: 600;">
                Share Your Experience
              </h1>
            </td>
          </tr>
          
          <!-- Content -->
          <tr>
            <td style="padding: 20px 40px 40px;">
              <p style="margin: 0 0 20px; color: #a3a3a3; font-size: 16px; line-height: 1.6;">
                Hi ${clientName},
              </p>
              <p style="margin: 0 0 20px; color: #a3a3a3; font-size: 16px; line-height: 1.6;">
                ${freelancerName} would love to hear about your experience working together${projectName ? ` on <strong style="color: #ffffff;">${projectName}</strong>` : ""}.
              </p>
              <p style="margin: 0 0 30px; color: #a3a3a3; font-size: 16px; line-height: 1.6;">
                Your feedback helps them improve and helps other clients make informed decisions. It only takes a minute!
              </p>
              
              <!-- CTA Button -->
              <table width="100%" cellpadding="0" cellspacing="0">
                <tr>
                  <td align="center">
                    <a href="${magicLink}" style="display: inline-block; padding: 16px 32px; background: linear-gradient(135deg, #8b5cf6, #7c3aed); color: #ffffff; text-decoration: none; border-radius: 8px; font-weight: 600; font-size: 16px;">
                      Share Your Feedback
                    </a>
                  </td>
                </tr>
              </table>
              
              <p style="margin: 30px 0 0; color: #737373; font-size: 14px; line-height: 1.6;">
                Or copy this link:<br>
                <a href="${magicLink}" style="color: #8b5cf6; word-break: break-all;">${magicLink}</a>
              </p>
            </td>
          </tr>
          
          <!-- Footer -->
          <tr>
            <td style="padding: 20px 40px; background-color: #0f0f0f; border-top: 1px solid #262626;">
              <p style="margin: 0; color: #525252; font-size: 12px; text-align: center;">
                This link expires in 30 days and can only be used once.
              </p>
            </td>
          </tr>
        </table>
        
        <p style="margin: 20px 0 0; color: #525252; font-size: 12px;">
          Powered by <a href="https://sovereign.com" style="color: #8b5cf6; text-decoration: none;">Sovereign</a>
        </p>
      </td>
    </tr>
  </table>
</body>
</html>
`;
}
```

### `src/app/api/testimonials/request/route.ts`

```typescript
import { auth } from "@clerk/nextjs/server";
import { NextRequest, NextResponse } from "next/server";
import { db } from "@/lib/db";
import { users, clients, testimonials } from "@/lib/db/schema";
import { eq } from "drizzle-orm";
import { sendEmail } from "@/lib/email";
import { testimonialRequestEmail } from "@/lib/email/templates/testimonial-request";
import { generateId } from "@/lib/utils";

export async function POST(req: NextRequest) {
  try {
    const { userId: clerkId } = await auth();

    if (!clerkId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const user = await db.query.users.findFirst({
      where: eq(users.clerkId, clerkId),
    });

    if (!user) {
      return NextResponse.json({ error: "User not found" }, { status: 404 });
    }

    const body = await req.json();
    const { clientId, portfolioItemId, message } = body;

    if (!clientId) {
      return NextResponse.json(
        { error: "Client ID is required" },
        { status: 400 }
      );
    }

    // Get client
    const client = await db.query.clients.findFirst({
      where: eq(clients.id, clientId),
    });

    if (!client) {
      return NextResponse.json({ error: "Client not found" }, { status: 404 });
    }

    if (!client.email) {
      return NextResponse.json(
        { error: "Client has no email address" },
        { status: 400 }
      );
    }

    // Generate magic link token
    const magicToken = generateId(32);
    const expiresAt = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000); // 30 days

    // Create testimonial request
    const [testimonial] = await db
      .insert(testimonials)
      .values({
        userId: user.id,
        clientId: client.id,
        portfolioItemId: portfolioItemId || null,
        type: "pending",
        clientName: client.name,
        clientCompany: client.company,
        magicLinkToken: magicToken,
        magicLinkExpiresAt: expiresAt,
      })
      .returning();

    // Build magic link
    const baseUrl = process.env.NEXT_PUBLIC_APP_URL || "http://localhost:3000";
    const magicLink = `${baseUrl}/testimonial/${magicToken}`;

    // Send email
    try {
      await sendEmail({
        to: client.email,
        subject: `${user.name || "Someone"} would love your feedback`,
        html: testimonialRequestEmail({
          freelancerName: user.name || "Your contact",
          clientName: client.name,
          magicLink,
        }),
      });
    } catch (emailError) {
      console.error("Failed to send email:", emailError);
      // Don't fail the whole request if email fails
    }

    return NextResponse.json({
      success: true,
      testimonialId: testimonial.id,
      magicLink, // Include for development/testing
    });
  } catch (error) {
    console.error("Testimonial request error:", error);
    return NextResponse.json(
      { error: "Failed to send testimonial request" },
      { status: 500 }
    );
  }
}
```

### `src/app/api/testimonials/submit/route.ts`

```typescript
import { NextRequest, NextResponse } from "next/server";
import { db } from "@/lib/db";
import { testimonials } from "@/lib/db/schema";
import { eq } from "drizzle-orm";

export async function POST(req: NextRequest) {
  try {
    const formData = await req.formData();

    const token = formData.get("token") as string;
    const type = formData.get("type") as "text" | "video";
    const rating = parseInt(formData.get("rating") as string) || 5;
    const content = formData.get("content") as string | null;
    const clientName = formData.get("clientName") as string | null;
    const clientTitle = formData.get("clientTitle") as string | null;
    const clientCompany = formData.get("clientCompany") as string | null;
    const videoFile = formData.get("video") as File | null;

    if (!token) {
      return NextResponse.json(
        { error: "Token is required" },
        { status: 400 }
      );
    }

    // Find testimonial by token
    const testimonial = await db.query.testimonials.findFirst({
      where: eq(testimonials.magicLinkToken, token),
    });

    if (!testimonial) {
      return NextResponse.json(
        { error: "Invalid or expired link" },
        { status: 404 }
      );
    }

    // Check if already submitted
    if (testimonial.type !== "pending") {
      return NextResponse.json(
        { error: "Testimonial already submitted" },
        { status: 400 }
      );
    }

    // Check expiration
    if (
      testimonial.magicLinkExpiresAt &&
      new Date() > testimonial.magicLinkExpiresAt
    ) {
      return NextResponse.json({ error: "Link has expired" }, { status: 400 });
    }

    // Handle video upload if present
    let videoUrl: string | null = null;
    if (videoFile && type === "video") {
      // In production, upload to cloud storage
      // For now, we'll just note that video was submitted
      // This would integrate with UploadThing or GCS
      console.log("Video submitted:", videoFile.name, videoFile.size);
      videoUrl = "pending_upload";
    }

    // Update testimonial
    await db
      .update(testimonials)
      .set({
        type,
        content: content || null,
        videoUrl,
        rating,
        clientName: clientName || testimonial.clientName,
        clientTitle: clientTitle || null,
        clientCompany: clientCompany || testimonial.clientCompany,
        collectedAt: new Date(),
        isApproved: false, // Require manual approval
      })
      .where(eq(testimonials.id, testimonial.id));

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("Testimonial submit error:", error);
    return NextResponse.json(
      { error: "Failed to submit testimonial" },
      { status: 500 }
    );
  }
}
```

### `src/app/api/testimonials/[id]/approve/route.ts`

```typescript
import { auth } from "@clerk/nextjs/server";
import { NextRequest, NextResponse } from "next/server";
import { db } from "@/lib/db";
import { users, testimonials } from "@/lib/db/schema";
import { eq, and } from "drizzle-orm";

export async function POST(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const { userId: clerkId } = await auth();

    if (!clerkId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const user = await db.query.users.findFirst({
      where: eq(users.clerkId, clerkId),
    });

    if (!user) {
      return NextResponse.json({ error: "User not found" }, { status: 404 });
    }

    // Update testimonial
    const [updated] = await db
      .update(testimonials)
      .set({ isApproved: true })
      .where(
        and(
          eq(testimonials.id, params.id),
          eq(testimonials.userId, user.id)
        )
      )
      .returning();

    if (!updated) {
      return NextResponse.json(
        { error: "Testimonial not found" },
        { status: 404 }
      );
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("Testimonial approval error:", error);
    return NextResponse.json(
      { error: "Failed to approve testimonial" },
      { status: 500 }
    );
  }
}
```

---

## 4. Real-time Updates (Using Pusher)

### Install Dependencies

```bash
npm install pusher pusher-js
```

### `src/lib/pusher/server.ts`

```typescript
import Pusher from "pusher";

if (
  !process.env.PUSHER_APP_ID ||
  !process.env.PUSHER_KEY ||
  !process.env.PUSHER_SECRET ||
  !process.env.PUSHER_CLUSTER
) {
  console.warn("Pusher environment variables not set - real-time disabled");
}

export const pusher = process.env.PUSHER_APP_ID
  ? new Pusher({
      appId: process.env.PUSHER_APP_ID,
      key: process.env.PUSHER_KEY!,
      secret: process.env.PUSHER_SECRET!,
      cluster: process.env.PUSHER_CLUSTER!,
      useTLS: true,
    })
  : null;

export type PusherEvent =
  | "contract:analyzed"
  | "contract:updated"
  | "client:updated"
  | "testimonial:received"
  | "notification:new"
  | "scope-creep:detected";

export async function triggerEvent(
  channel: string,
  event: PusherEvent,
  data: any
) {
  if (!pusher) {
    console.log(`[Pusher disabled] ${channel}:${event}`, data);
    return;
  }

  try {
    await pusher.trigger(channel, event, data);
  } catch (error) {
    console.error("Pusher trigger error:", error);
  }
}

// Helper to get user's private channel
export function getUserChannel(userId: string) {
  return `private-user-${userId}`;
}
```

### `src/lib/pusher/client.ts`

```typescript
"use client";

import PusherClient from "pusher-js";

let pusherInstance: PusherClient | null = null;

export function getPusherClient(): PusherClient | null {
  if (typeof window === "undefined") return null;

  if (!process.env.NEXT_PUBLIC_PUSHER_KEY) {
    console.warn("Pusher key not set");
    return null;
  }

  if (!pusherInstance) {
    pusherInstance = new PusherClient(process.env.NEXT_PUBLIC_PUSHER_KEY, {
      cluster: process.env.NEXT_PUBLIC_PUSHER_CLUSTER || "us2",
      authEndpoint: "/api/pusher/auth",
    });
  }

  return pusherInstance;
}
```

### `src/app/api/pusher/auth/route.ts`

```typescript
import { auth } from "@clerk/nextjs/server";
import { NextRequest, NextResponse } from "next/server";
import { pusher } from "@/lib/pusher/server";
import { db } from "@/lib/db";
import { users } from "@/lib/db/schema";
import { eq } from "drizzle-orm";

export async function POST(req: NextRequest) {
  try {
    if (!pusher) {
      return NextResponse.json(
        { error: "Pusher not configured" },
        { status: 500 }
      );
    }

    const { userId: clerkId } = await auth();

    if (!clerkId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const user = await db.query.users.findFirst({
      where: eq(users.clerkId, clerkId),
    });

    if (!user) {
      return NextResponse.json({ error: "User not found" }, { status: 404 });
    }

    const body = await req.formData();
    const socketId = body.get("socket_id") as string;
    const channel = body.get("channel_name") as string;

    // Verify channel access
    const expectedChannel = `private-user-${user.id}`;
    if (channel !== expectedChannel) {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
    }

    const authResponse = pusher.authorizeChannel(socketId, channel, {
      user_id: user.id,
    });

    return NextResponse.json(authResponse);
  } catch (error) {
    console.error("Pusher auth error:", error);
    return NextResponse.json(
      { error: "Authentication failed" },
      { status: 500 }
    );
  }
}
```

### `src/hooks/use-realtime.ts`

```typescript
"use client";

import { useEffect, useCallback, useState } from "react";
import { getPusherClient } from "@/lib/pusher/client";
import type { Channel } from "pusher-js";

interface UseRealtimeOptions {
  userId: string;
  onContractAnalyzed?: (data: any) => void;
  onTestimonialReceived?: (data: any) => void;
  onNotification?: (data: any) => void;
  onScopeCreepDetected?: (data: any) => void;
}

export function useRealtime({
  userId,
  onContractAnalyzed,
  onTestimonialReceived,
  onNotification,
  onScopeCreepDetected,
}: UseRealtimeOptions) {
  const [connected, setConnected] = useState(false);
  const [channel, setChannel] = useState<Channel | null>(null);

  useEffect(() => {
    const pusher = getPusherClient();
    if (!pusher || !userId) return;

    const channelName = `private-user-${userId}`;
    const userChannel = pusher.subscribe(channelName);

    userChannel.bind("pusher:subscription_succeeded", () => {
      setConnected(true);
      console.log("Connected to real-time channel");
    });

    userChannel.bind("pusher:subscription_error", (err: any) => {
      console.error("Subscription error:", err);
      setConnected(false);
    });

    // Bind events
    if (onContractAnalyzed) {
      userChannel.bind("contract:analyzed", onContractAnalyzed);
    }

    if (onTestimonialReceived) {
      userChannel.bind("testimonial:received", onTestimonialReceived);
    }

    if (onNotification) {
      userChannel.bind("notification:new", onNotification);
    }

    if (onScopeCreepDetected) {
      userChannel.bind("scope-creep:detected", onScopeCreepDetected);
    }

    setChannel(userChannel);

    return () => {
      userChannel.unbind_all();
      pusher.unsubscribe(channelName);
      setConnected(false);
    };
  }, [userId, onContractAnalyzed, onTestimonialReceived, onNotification, onScopeCreepDetected]);

  return { connected, channel };
}
```

### `src/components/providers/realtime-provider.tsx`

```typescript
"use client";

import { createContext, useContext, useCallback, useEffect } from "react";
import { useRealtime } from "@/hooks/use-realtime";
import { useRouter } from "next/navigation";
import { toast } from "sonner";

interface RealtimeContextType {
  connected: boolean;
}

const RealtimeContext = createContext<RealtimeContextType>({
  connected: false,
});

export function useRealtimeContext() {
  return useContext(RealtimeContext);
}

interface RealtimeProviderProps {
  userId: string;
  children: React.ReactNode;
}

export function RealtimeProvider({ userId, children }: RealtimeProviderProps) {
  const router = useRouter();

  const handleContractAnalyzed = useCallback(
    (data: any) => {
      toast.success("Contract analysis complete!", {
        description: `${data.title} has been analyzed`,
        action: {
          label: "View",
          onClick: () => router.push(`/dashboard/contracts/${data.contractId}`),
        },
      });
      router.refresh();
    },
    [router]
  );

  const handleTestimonialReceived = useCallback(
    (data: any) => {
      toast.success("New testimonial received!", {
        description: `${data.clientName} submitted a testimonial`,
        action: {
          label: "View",
          onClick: () => router.push("/dashboard/testimonials"),
        },
      });
      router.refresh();
    },
    [router]
  );

  const handleNotification = useCallback(
    (data: any) => {
      toast(data.title, {
        description: data.message,
      });
    },
    []
  );

  const handleScopeCreep = useCallback(
    (data: any) => {
      toast.warning("Scope creep detected!", {
        description: data.description,
        action: {
          label: "Review",
          onClick: () => router.push(`/dashboard/contracts/${data.contractId}`),
        },
        duration: 10000,
      });
    },
    [router]
  );

  const { connected } = useRealtime({
    userId,
    onContractAnalyzed: handleContractAnalyzed,
    onTestimonialReceived: handleTestimonialReceived,
    onNotification: handleNotification,
    onScopeCreepDetected: handleScopeCreep,
  });

  return (
    <RealtimeContext.Provider value={{ connected }}>
      {children}
    </RealtimeContext.Provider>
  );
}
```

### Update Dashboard Layout with Real-time

#### `src/app/(dashboard)/layout.tsx`

```typescript
import { auth } from "@clerk/nextjs/server";
import { redirect } from "next/navigation";
import { db } from "@/lib/db";
import { users } from "@/lib/db/schema";
import { eq } from "drizzle-orm";
import { DashboardSidebar } from "@/components/dashboard/sidebar";
import { DashboardHeader } from "@/components/dashboard/header";
import { CommandMenu } from "@/components/dashboard/command-menu";
import { RealtimeProvider } from "@/components/providers/realtime-provider";
import { Toaster } from "sonner";

export default async function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const { userId: clerkId } = await auth();

  if (!clerkId) {
    redirect("/login");
  }

  const user = await db.query.users.findFirst({
    where: eq(users.clerkId, clerkId),
  });

  return (
    <div className="min-h-screen bg-neutral-950">
      {/* Background Pattern */}
      <div className="fixed inset-0 bg-gradient-mesh opacity-50 pointer-events-none" />
      <div className="fixed inset-0 pattern-dots opacity-30 pointer-events-none" />

      {user ? (
        <RealtimeProvider userId={user.id}>
          <div className="relative flex h-screen overflow-hidden">
            <DashboardSidebar />
            <div className="flex-1 flex flex-col overflow-hidden">
              <DashboardHeader />
              <main className="flex-1 overflow-y-auto">
                <div className="container max-w-7xl mx-auto p-6">{children}</div>
              </main>
            </div>
          </div>
          <CommandMenu />
        </RealtimeProvider>
      ) : (
        <div className="relative flex h-screen overflow-hidden">
          <DashboardSidebar />
          <div className="flex-1 flex flex-col overflow-hidden">
            <DashboardHeader />
            <main className="flex-1 overflow-y-auto">
              <div className="container max-w-7xl mx-auto p-6">{children}</div>
            </main>
          </div>
        </div>
      )}

      <Toaster
        position="bottom-right"
        toastOptions={{
          style: {
            background: "#171717",
            border: "1px solid #262626",
            color: "#fff",
          },
        }}
      />
    </div>
  );
}
```

### Example: Triggering Real-time Events

Update the contract analysis to trigger real-time events:

#### Add to `src/app/api/contracts/analyze/route.ts`:

```typescript
// Add at the top
import { triggerEvent, getUserChannel } from "@/lib/pusher/server";

// After saving the contract, add:
await triggerEvent(
  getUserChannel(user.id),
  "contract:analyzed",
  {
    contractId: contract.id,
    title: contract.title,
    riskScore: analysis.overallRiskScore,
    riskCount: analysis.risks.length,
  }
);
```

---

## Environment Variables to Add

Add these to your `.env.local`:

```bash
# Google AI (Gemini)
GOOGLE_GENERATIVE_AI_API_KEY=your_key_here

# UploadThing
UPLOADTHING_TOKEN=your_token_here

# Resend (Email)
RESEND_API_KEY=re_your_key_here

# Pusher (Real-time)
PUSHER_APP_ID=your_app_id
PUSHER_KEY=your_key
PUSHER_SECRET=your_secret
PUSHER_CLUSTER=us2
NEXT_PUBLIC_PUSHER_KEY=your_key
NEXT_PUBLIC_PUSHER_CLUSTER=us2
```

---

## Summary of What's Now Complete

| Feature | Status | Details |
|---------|--------|---------|
| **Contract Analysis** | ✅ | Gemini Flash, PDF/DOC parsing, risk scoring |
| **File Uploads** | ✅ | UploadThing integration, drag-drop UI |
| **Testimonial System** | ✅ | Magic links, email templates, video support |
| **Real-time Updates** | ✅ | Pusher integration, toast notifications |

---

## Testing

```bash
# 1. Install new dependencies
npm install @ai-sdk/google ai pdf-parse mammoth uploadthing @uploadthing/react resend pusher pusher-js

# 2. Add environment variables to .env.local

# 3. Push any schema changes
npx drizzle-kit push

# 4. Start the dev server
npm run dev
```

### Test Each Feature:

1. **Contract Analysis**: Go to `/dashboard/contracts/analyze`, upload a PDF
2. **File Uploads**: The contract upload uses the new system
3. **Testimonials**: Go to `/dashboard/testimonials`, click "Request Testimonial"
4. **Real-time**: Open two browser tabs, analyze a contract - see the notification

---
